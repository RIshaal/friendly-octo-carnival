#include "RP6RobotBaseLib.h"
#include "RP6I2CslaveTWI.h" // Include the I2C Library file (!!!)
  
#define CMD_MOVE_FWD 1 // laat naar voren rijden
#define CMD_MOVE_BWD 2 // laat naar achter rijden
#define CMD_SET_LEDS 3 // LED command, which should be received
#define CMD_MOVE_LEFT 4 // laat naar links draaien
#define CMD_MOVE_RIGHT 5 // laat naar rechts draaien
#define CMD_STOP 6 // STOP


unsigned char actuele_status;

//zet de oude status op een 'onbekende status' zodat de eerste vergelijking direct de actuele status oplevert
unsigned char oude_status=4;

//============================================================
//   HAAL ACTUELE STATUS OP
//============================================================
unsigned char haal_actuele_status(void){

   //geen van beide sensors vindt een obstakel
   if(!obstacle_left && !obstacle_right)
   {
      //retourneer: 'geen obstakel'
      return 0;
   }
   else
   //alleen linker sensor vindt een obstakel
   if(obstacle_left && !obstacle_right)
   {
      //retourneer: 'alleen links een obstakel'
      return 1;
   }
   else
   //alleen rechter sensor vindt een obstakel
   if(!obstacle_left && obstacle_right)
   {
      //retourneer: 'alleen rechts een obstakel'
      return 2;
   }
   else
   // ... dan blijft blijft alleen nog over...: (meer combinaties zijn er niet)   
   //zowel linker sensor als rechter sensor vindt een obstakel
   {
      //retourneer: 'links en rechts een obstakel'
      return 3;
   }
}
//============================================================
//   ACS
//============================================================
void acs(void)
{

   //haal actuele status op
   actuele_status = haal_actuele_status();
   
   //de status is gewijzigd
   if ( actuele_status != oude_status ) {
   
      //onthoud de actuele status als oude status, voor als er later opnieuw vergeleken wordt
      oude_status = actuele_status ;

      //start de stopwatch
      setStopwatch1(0);

   }
	if(actuele_status == 1)
		{
			setLEDs(0b111000);
			moveAtSpeed(0,0);
		
			if(actuele_status == 1)
			{
				rotate(75, LEFT, 95, BLOCKING);
			}
			else
			{
			changeDirection(FWD);
			moveAtSpeed(80,80);

			oude_status=4;
			}
        }
   //----------------------------------------
   // alleen rechter sensor detecteert iets
   //----------------------------------------
   if(actuele_status==2)
   { 
			setLEDs(0b000111);
			moveAtSpeed(0,0);
			//setStopwatch1(0);
		if(getStopwatch1()>100)
			{
				rotate(75, RIGHT, 90, BLOCKING);
			}
		if(actuele_status == 2)
			{
				rotate(75, RIGHT, 95, BLOCKING);
			}
			else
			{
			changeDirection(FWD);
			moveAtSpeed(80,80);
			
			oude_status=4;
			}
            
   }
   //----------------------------------------
   // geen van beide sensoren detecteert iets
   //----------------------------------------
/*   if(actuele_status==0)
      {
         setLEDs(0b000000);
         changeDirection(FWD);
         moveAtSpeed(80,80);
      }
*/      
}   
void bumpersStateChanged(void)
{
    if(bumper_left || bumper_right) 
    {
        moveAtSpeed(0,0);  // stop moving!
        setLEDs(0b010000);
        startStopwatch1();
    }
}
  
void blink(void)
{
    if(getStopwatch1() > 500) // 500ms
    {
        statusLEDs.LED2 = !statusLEDs.LED2; // Toggle LED bit in LED shadow register... 
        statusLEDs.LED5 = !statusLEDs.LED5;
        updateStatusLEDs();
        setStopwatch1(0);
    }
}
  
int main(void)
{
  
initRobotBase();
I2CTWI_initSlave(10); // Initialise TWI set slave address to 10
powerON();
startStopwatch1();
//enableACS();
setACSPwrMed();
  
    while(true)
    {// did we receive some command and is there NO write access?      
        BUMPERS_setStateChangedHandler(bumpersStateChanged);
        task_RP6System();
		acs();
          
  
            if(I2CTWI_writeRegisters[0] && !I2CTWI_writeBusy)
                {
                // save register contents:
                uint8_t cmd = I2CTWI_writeRegisters[0];
                I2CTWI_writeRegisters[0] = 0; // and reset cmd reg (!!!)
                uint8_t param1 = I2CTWI_writeRegisters[1]; // Parameter
                uint8_t param2 = I2CTWI_writeRegisters[2];
  
                if(cmd == CMD_SET_LEDS) //CMD 3
                    {
                        setLEDs(param1);
                    } 
  
                if(cmd == CMD_MOVE_FWD) //CMD1 // MOVE FORWARD command received?// set move with the parameter
                    {
                        changeDirection(FWD);
                        moveAtSpeed(param1,param2);
                    }
              
                if(cmd == CMD_MOVE_BWD)//CMD 2 // Achteruit
                    {
                        changeDirection(BWD);
                        moveAtSpeed(param1,param2);
                    }
                  
                if(cmd == CMD_MOVE_LEFT) //CMD 4 
                    {
                        rotate(75, LEFT, 90, BLOCKING);
                    }
                      
                if(cmd == CMD_MOVE_RIGHT) //CMD 5   
                    {
                        rotate(75, RIGHT, 90, BLOCKING);
                    }
                      
                if(cmd == CMD_STOP) // CMD 6
                    {
                        moveAtSpeed(0,0);
                    }
                  
                          
                if(!I2CTWI_readBusy) // No read activities?
                // Proceed by writing current LED state to register 0:
                I2CTWI_readRegisters[0] = statusLEDs.byte;
            }
              
    }
    return 0;
} 
